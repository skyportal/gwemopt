#!/usr/bin/python

# Copyright (C) 2017 Michael Coughlin
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

""".
Gravitational-wave Electromagnetic Optimization

This script generates an optimized list of pointings and content for
reviewing gravitational-wave skymap likelihoods.

Comments should be e-mailed to michael.coughlin@ligo.org.

"""


import os, sys, glob, optparse, shutil, warnings
import numpy as np
np.random.seed(0)

import healpy as hp

if not os.getenv("DISPLAY", None):
    import matplotlib
    matplotlib.use("agg", warn=False)

__author__ = "Michael Coughlin <michael.coughlin@ligo.org>"
__version__ = 1.0
__date__    = "6/17/2017"

# =============================================================================
#
#                               DEFINITIONS
#
# =============================================================================

def parse_commandline():
    """@Parse the options given on the command-line.
    """
    parser = optparse.OptionParser(usage=__doc__,version=__version__)

    parser.add_option("-s", "--skymap", help="GW skymap.", default='../output/skymaps/GRB20180626.fits')

    parser.add_option("--doCircle",  action="store_true", default=False)
    parser.add_option("--ra",default=248.046,type=float)
    parser.add_option("--dec",default=49.028,type=float)
    parser.add_option("--radius",default=20.317/3.0,type=float)
    parser.add_option("--nside",default=256,type=int)

    parser.add_option("--doSquare",  action="store_true", default=False)
    parser.add_option("--ras",default="290.010,290.186,265.423,264.736")
    parser.add_option("--decs",default="48.528,48.912,43.214,42.455")

    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help="Run verbosely. (Default: False)")

    opts, args = parser.parse_args()

    # show parameters
    if opts.verbose:
        print >> sys.stderr, ""
        print >> sys.stderr, "running gwemopt_run..."
        print >> sys.stderr, "version: %s"%__version__
        print >> sys.stderr, ""
        print >> sys.stderr, "***************** PARAMETERS ********************"
        for o in opts.__dict__.items():
          print >> sys.stderr, o[0]+":"
          print >> sys.stderr, o[1]
        print >> sys.stderr, ""

    return opts

def gen_circle(ra,dec,error,nside):

    npix = hp.nside2npix(nside)
    p = hp.ang2pix(nside, ra, dec, lonlat=True)
    n = np.zeros(npix)
    n[p] = 1.
    healpix = hp.smoothing(n, sigma=np.deg2rad(error), verbose=False)
    healpix = healpix / np.sum(healpix)

    return healpix

def gen_square(ras,decs,nside):

    radecs = []
    for r,d in zip(ras,decs):
        radecs.append([r,d])
    radecs = np.array(radecs)

    xyz = []
    for r, d in radecs:
        xyz.append(hp.ang2vec(r, d, lonlat=True))

    npts, junk = radecs.shape
    if npts == 4:
        ipix = hp.query_polygon(nside, np.array(xyz))
    else:
        ipix = hp.query_polygon(nside, np.array(xyz))

    npix = hp.nside2npix(nside)
    n = np.zeros(npix)
    n[ipix] = 1.
    healpix = n / np.sum(n)

    return healpix

# =============================================================================
#
#                                    MAIN
#
# =============================================================================

warnings.filterwarnings("ignore")

# Parse command line
opts = parse_commandline()

if opts.doCircle:
    healpix = gen_circle(opts.ra,opts.dec,opts.radius,opts.nside)
elif opts.doSquare:
    ras = [float(x) for x in opts.ras.split(",")]
    decs = [float(x) for x in opts.decs.split(",")]
    healpix = gen_square(ras,decs,opts.nside)
else:
    print("Please specify --doCircle or --doSquare")
    exit(0)

hp.fitsfunc.write_map(opts.skymap,healpix,overwrite=True)

